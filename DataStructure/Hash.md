# Hash

-   저장하고자 하는 정보 Value
-   Value를 구분할 수 있는 고유한 data : Key → 어떤 데이터를 쓸지에 따라 정할 수 있으며, 중복되지 않아야 함
-   해시함수
    -   key를 입력으로 넣어주면 해시값이라는 결과 출력. 해시값을 인덱스화 하여 데이터 저장
    -   임의의 데이터(KEY)를 특정 값(해시값)으로 매핑시키는 함수
    -   데이터가 많아도 위치를 바로 찾을 수 있음
    -   시간복잡도 O(1)
-   Hash table내 데이터가 저장되는 공간을 buckets
-   해싱
    -   데이터를 빠르게 가져오고 저장하는 기법
-   해시 테이블
    -   Key, Value 쌍을 저장
    -   순서는 존재하지 않음
-   KEY
    -   ex)아이디, 주민번호와 같은 고유한 정보
-   좋은 해시 함수
    -   키 값을 고르게 분포 시키기
    -   해시 값을 계산해주는 속도 빠름 - 스캔하는 속도보다 해시함수 속도가 느리면 의미 없음
    -   해시 충돌(키 값이 다른데, 해시 함수의 결과값이 동일한 경우) 최소화
        -   해시 자료구조 성능을 떨어지게 하는 가장 큰 원인
        -   충돌해결 방식 - LinkedList를 이용한 chaining방식 이용
            -   특정 키에 해시함수로 낳은 해시값을 인덱스화 하여 데이터 저장
            -   다른 키를 넣었는데 똑같은 해시값이 나오면 같은 인덱스 위치를 가르키게 되고, 데이터가 있다면 데이터가 저장된 버킷이 다음 노드를 가르키게 함. → 계속해서 새로운 노드를 연결하는 것임
            -   chaining 방식으로 해시충돌 회피할 경우 인덱스 위치를 찾는데 O(1)의 시간복잡도가 걸린다 하더라고, 인덱스의 위치에서 값을 찾기 위해 리스트를 탐색하는 과정을 거쳐야 함. 최악의 경우 O(N)의 시간복잡도.
            -   리스트 대신 tree라는 자료구조를 사용함
        -   Open Addressing
            -   충돌이 발생할 경우 다른 버킷에 데이터 저장하는 방식
            -   선형 탐색 : 해시 충돌 시 n칸을 건너뛴 다음 버킷에 저장
                -   단순계산, 시간 소요多, 데이터들의 특정 위치 밀집(→ 밀집 될 수록 충돌로 데이터의 위치를 재탐색 하는 일이 많아짐 : 성능 저하) 데이터가 밀집되는 현상 : **클러스터링**
                -   클러스터링을 피하기 위해 → 제곱 탐색 : N^2칸을 건너뛰어 저장⇒ 이중 해시 라는 방법이 나옴 : 해시 값에 다른 해시 함수를 한번 더 적용
                    -   Hashfunction1() : 최초의 해시 값을 구하는 함수
                    -   Hashfunction2() : 충돌이 발생했을 때 돌리는 해시함수
                        -   충돌이 발생했을 때 몇 칸을 이동할지 이 해쉬 함수를 통해 구하게 됨
                        -   최초의 해시값이 같아도 이동 폭이 달라 클러스터링 문제 해결 가능
                -   ⇒ Ex) 1, 4, 9, 16, ... → But, 처음 해시함수를 통해 나온 해시값이 동일하다면 마찬가지로 건너뛴 칸의 갯수도 똑같음
    -   비둘기 집 원리
        -   N+1개 물건을 N개의 상자에 넣을때 하나의 상자는 두개 이상의 물건이 들어있음
        -   해시테이블은 인덱스의 수가 한정되어 있지만 키 값은 훨씬 많음
    -   Birthday Problem
        -   N명이 모였을 때 생일이 같은 두 명이 존재할 확률
        -   수학적 확률로 계산했을 때 23명만 모여도 50.7% 존재
        -   50명인 경우 97%

### 이진 탐색(Binary Search)
    1.  오름차순으로 정렬되어 있는 리스트에서 특정 값의 인덱스를 찾는 알고리즘
    2.  속도가 빠름 (시간복잡도 O(logN)) //N=100 일때 logN=6.64
    3.  정렬된 리스트에서만 사용 가능